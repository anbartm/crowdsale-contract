# The CoFab crowdsale and token contracts! 🐵

A token and crowdsale contract. Structured as a Truffle project within a node
package. Create a token and a crowdsale and deploy them to a local RPC, a
testnet or the ethereum mainnet!

Installing this installs all the dependencies locally, so you don't have to
worry about conflicting truffle or solc versions.

## Setting up the project 🔧

* Install [node](https://nodejs.org) and [yarn](https://yarnpkg.com/)
* Do `yarn install`. This will install truffle and ganache-cli locally

## Start a ganache-cli server 📟

To start the ganache local blockchain, open a new terminal instance and run
`yarn start`. If you want a graphical interface, download and install the [UI
version of ganache](https://truffleframework.com/ganache) and run it at
`http://127.0.0.1:8545`

## Running the tests 🚂

Once `ganache-cli` is running, do `yarn truffle test` to deploy
the test contracts on your ganache server and run the tests.

## Deploying the contracts to the local ganache server 🚀

You can deploy the test contracts on your local ganache server by
running:

`yarn truffle migrate --reset`

## Interacting with your smart contracts 🎹

Once you've deployed them to your local ganache, you can interact with
the test contracts by running `yarn truffle console`. You can call all the
external functions of the contracts:

```
$ yarn truffle console
> CrowdsaleTest.deployed().then(instance => crowdsale = instance)
> crowdsale.crowdsaleStartTime().then(x => x.toNumber())
1519747200
```

Let's add an address to the crowdsale's whitelist and set its max
contribution to 2 ether:

```
> crowdsale.editContributors(['0x0d1d4e623d10f9fba5db95830f7d3839406c6af2'],[web3.toWei(2, 'ether')])
```

We pass the values as singleton lists because the function supports
adding multiple entries at once.

It's also possible to kill contracts, meaning that they stop functioning and their
code gets deleted.

```
> crowdsale.kill()
```

## Deploying the contracts to kovan 🎷

Get your hands on a wallet that has some kETH. Then, exit the truffle console
if it was already running and set the env variable MNEMONIC to that wallet's
mnemonic:

`export MNEMONIC="topple limb ritual hen total large cover horror purse place primary gas"`

**⚠️ Don't use this mnemonic to make real wallets! ⚠️**

Edit `crowdsale.conf.js` to adjust the parameters of your crowdsale and token.
Example values are already in place, so you don't have to adjust them to deploy
to kovan.

Do the deployment:

`yarn truffle migrate --network kovan`

The output will be something similar to this:

````
Using network 'kovan'.

Running migration: 1_initial_migration.js
  Replacing Migrations...
  ... 0xa93aa952556d73592d308ed4bf1c86cdebc20d99720dd93d18ae94be14cb71db
  Migrations: 0xb07185f717b81b7a8139becfbe31f95cc4f07ea0
Saving successful migration to network...
  ... 0x85584b4dbb4c8e65d833407bccbf966fbcc093e80d99e22b9c44558c7b81da7b
Saving artifacts...
Running migration: 2_migrate_all.js
  Replacing Crowdsale...
  ... 0x009830b24dae129e59006adff5c64687e52a5a0eed08797751cbeba8768656bd
  Crowdsale: 0x72a546f651a2430adc7d593140435ed58490f55a
  Replacing Token...
  ... 0xb6d2d1c67c57e23f8043d82c48eb24e3f3a5b028c6c4d2b81d4bad1f17bfd91c
  Token: 0x5c33d355c9bedda260829518dcf1d2298489b2ef
Saving successful migration to network...
  ... 0x931478c116a872ec2a8f749bad40ace3e46c2b2d8467e798712d047bf50b40b3
Saving artifacts...```
````

We see that our crowdsale contract has been deployed to the address
`0x72a546f651a2430adc7d593140435ed58490f55a`. Of course, if you do your
own deployment, the address will be different. You can search for that
address on (Kovan Etherscan)[https://kovan.etherscan.io] to see that
your contract has really been deployed.

Interacting with the contracts:

```
$ yarn truffle console --network kovan
> Crowdsale.deployed().then(instance => crowdsale = instance)
> crowdsale.crowdsaleStartTime().then(x => x.toNumber())
1519747200
```

## Deploying to main net 🎓

Same as deploying to kovan, just with the `live` network.

`yarn truffle migrate --network live`

Be careful though, the wallet that's generated by your mnemonic has to have some
real ETH on it. Ideally, **the mnemonic should be stored as a secret** in your
CI pipeline, and it should not be your main wallet.
